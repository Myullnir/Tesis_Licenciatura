Código para generar .e a partir de los .c. Importante para el Prosem.c

"gcc -Wall -O3 -o miprog.e miprog.c -lm"

Para correr el programa el código es: "./miprog.e"

---------------------------------------------------------------------------------------

19/11/2020

Hoy voy a intentar revisar entre todos mis archivos viejos para organizarme todo lo que voy
a necesitar para empezar a trabajar. Tengo que revisar los .c, los .h, ver cómo funciona
el make file, cómo funciona el Ejecutar.sh, el Instanciar.sh.


---------------------------------------------------------------------------------------

25/11/2020

Voy a empezar a programar algunas boludeces, así ya voy de a poco recuperando el tacto con
esto. Después debería armarme un diagrama del orden de cosas para programar, así como la
jerarquía en que voy a plantear las funciones. Quizás convenga redefinir los nombres de
los archivos tipo avanzar, general y esos.

-----------------------------------------------------------------------------------------

26/11/2020

Luego de batallar con arrancar, ya estamos empezando. Me armé un diagrama de trabajo y una
lista de las cosas que tengo que poner en el programa. El diagrama lo tengo en una hoja
escrito a mano. Podría pasarlo a un power Point, ya veré si vale la pena.
Modifiqué el struct base, el llamado Red, para que tenga los elementos básicos que va a
necesitar el modelo. Tiene número de agentes, de tópicos, matriz de superposición, matriz de
adyacencia, vectores de opinión y una serie de parámetros más.
La próxima arrancamos con los elementos en inicializar. La función de Visualizar queda.
Creo que voy a borrar CCP y la otra la voy a modificar para que me arme la red. Arranquemos
con una inicialización fija, después planteamos que el sistema vaya variando los valores
de la matriz de superposición.

-----------------------------------------------------------------------------------------

27/11/2020

Bien, ya modifiqué el archivo de inicializar. Saqué el CCP que colocaba condiciones de
contorno cerradas. Esas no las voy a necesitar, porque al final mi sistema es una red
finita con N nodos, no hay condiciones de contorno que cumplir. Luego, el GenerarR lo adapte
para que me inicialice los vectores de opiniones. Lo probé, parece funcionar perfecto. Por
lo menos asigna números con fracción a todas las coordenadas correctamente. Pareciera
respetar el intervalo de valores. Le cambié el nombre al GenerarR y lo llamé GenerarOpi.

También modifiqué el programa de Visualizar, para que al final reciba un número que indique
qué vector es el que planeo mirar. Las opciones son "Vectores de Opiniones", "Matriz de
Superposición" y "Matriz de Adyacencia".

Además separé el struct original de Red en dos structs. El struct Red que contiene la matriz
de Superposición, la matriz de Adyacencia y la lista de vectores de opinión. El segundo
struct es Parametros, que contiene todos los parámetros del modelo.

Lo siguiente es armar dos funciones que me inicialicen la matriz de Superposición y la de
Adyacencia. De paso, se me acaba de ocurrir. Debería probar el numerar vectores con la 
notación usual de fila y columna "[i,j]", trabajándolos como matrices, en vez de trabajarlos
como vectores de una sola fila y muchas columnas, donde hago cosas como "[i*N+j]" para
designar los casilleros del vector.
Cuestión, cuando tenga todas las funciones de inicialización las voy a empaquetar en una
sola función, para que quede todo más prolijo. O quizás vea de encerrarlo en una pestaña.

Corte a las 9:40, me pareció que no valía matarse ahora. La dificultad ahora es cómo
escribir una matriz simétrica, considerando que yo las tengo armadas como una tira y no
como una matriz. Estoy seguro que alguna vuelta sencilla tiene que haber. Una propuesta que
tengo para los elementos diagonales y no tener que meter muchos if es armar todos los
elementos con algún criterio, (Armar una matriz random en cada instanciación no suena como
una buena idea.) y DESPUÉS reemplazar todos los elementos de la diagonal por 1.

-----------------------------------------------------------------------------------------

28/11/2020

Armé las funciones que estuve mencionando antes. Ya tengo GenerarOpi que me arma la lista
de vectores de Opinión de todos los agentes. También está GenerarAng, que me crea la mitad
de la matriz de Superposición. La otra mitad la voy a construir una vez que tenga armada
una función que me simetrice matrices. Esa función la voy a meter dentro del conjunto de
funciones generales, podría servir en un futuro. La situación es la misma con GenerarAdy. Me
genera la mitad de la matriz de Adyacencia, la otra la voy a construir por simetría.

Estuve probando el Visualizar. Algo raro le está pasando, pero empecemos aclarando que me
visualiza perfecto las matrices de Adyacencia  y Superposición. Pero por alguna razón viene
tirando un error con la matriz de Opiniones. Creo que el error es puramente en la 
visualización, que no tiene nada que ver con lo que realmente hay en la matriz. Me percaté
de esto para empezar porque observaba que los elementos de la última fila de esta matriz
cuando formaba el sistema con seis agentes eran todos cero. Algo estadísticamente improbable.
Cuestión, que dependiendo de la cantidad de filas los elementos de las últimas filas se ven
peor o mejor. Noté que si cambiaba a muchas filas y columnas, de repente todo se emparejaba.
También descarté que el problema sea el casteo o el armado del Vector. El casteo no es porque
pasé el vector a Double, que es la salida del Random, y sigue funcionando mal. El armado del
vector no es porque probé ponerle enteros, y sigue dando el error de que al visualizarlo me
muestra algo que no tiene sentido, como ceros en las últimas filas o números absurdamente
largos e inexplicables. Y estos números largos eran siempre los mismos, no cambiaban en un solo
número. Algo raro pasa ahi y todavía no descubrí qué es lo que está pasando. Para comprobar que
el vector está bien rellenado podrías armar una sumatoria con sus números y ver que den algo
correcto.

Ahora voy a armar una carpeta en Github para cargar todo esto. Yo diría que mañana vayas
haciendo pruebas con lo de sumatorias para verificar que el vector se llena de manera correcta.
Luego, empezá a revisar la visualización para ver qué clase de error puede estar teniendo. Al
final del día igual no es vital, pero bueno. Visualizar las redes puede facilitar el encontrar
errores.

-------------------------------------------------------------------------------------------

30/11/2020

Encontré el error. Al final el problema efectivamente estaba en la visualización. La culpa era
mía, obviamente. Yo le calculé mal el movimiento a lo largo de las filas. En pocas palabras, el
sujeto estaba yendo a mirar en posiciones de memoria que no le pertenecían al vector. Eso hizo
que visualizara cosas raras. Porque eran espacios de memoria que estaban ocupados por cosas
raras. De paso, le agregué a la visualización que se muestren sólo dos decimales después de
la coma. Para que sea más sencillo de ver.

Lo pensé mejor, voy a escribir el código de simetrización dentro de las mismas funciones de 
Generar*. Queda para el futuro armar funciones que tomen punteros, me midan el tamaño de los
punteros y desde ahí me simetricen la matriz. Igual, el proceso de simetrización es una línea.
Genial, ya se me simetrizan ambas matrices.

Bueno, armé dos funciones en los archivos de avanzar. Pero todavía no puedo decir que funcionen
bien. Probé hacer las cuentas. En el caso de un nodo sin conexión a nada, dan bárbaro las
cuentas. En el caso de que se conecte con alguien, ya no da tan bien. Todavía no descubro
porqué.

También me ocurrió algo inentendible para mi. En el struct me surgió un error incomprensible.
Agregué el diferencial de tiempo al struct, y lo puse junto a los otros float, por una cuestión
de orden, para agrupar los mismos tipos de datos. Cuestión que por alguna razón que no
comprendo, la posición de este elemento en el struct jodía todo el programa. Pero al cambiarlo
de lugar y llevarlo al fondo del struct, todo se organizaba y funcionaba bárbaro. Cosa que no
tiene sentido, porque el struct llama a sus elementos por nombre, no por posición. El orden
no debería importar. No sé porqué, pero alto error raro.

-------------------------------------------------------------------------------------------

05/12/2020

Por lo que leí en internet, no hay una forma en C de poder leer el tamaño del array al cual 
apunta el puntero. Pero lo que podemos hacer es un truco, y esto implica un cambio en la
forma de programar de ahora para SIEMPRE. Lo que vamos a hacer es que de ahora en más, al 
principio de cada vector los primeros dos números van a estar reservados para el tamaño
de la matriz. (Si es un vector, igual lo consideraré como matriz). De esta manera, siempre
podré tener acceso al tamaño de un array. Esto va a ser un cambio que voy a implementar mañana.

Ahora me voy a poner a jugar con los structs y cosas en Prosem.c. Quiero ver si puedo armar
funciones a las que les llegan punteros y de esa manera en vez de tener que pasar todo el struct,
le paso sólo el puntero correcto. ¿Porqué querrías volver a trabajar sólo con punteros, en vez de
usar el struct que es mejor? El tema es que los nombres de los elementos de los structs va
variando con cada trabajo, entonces una función como la de simetrizar matrices no puede trabajar
con recibir el struct, porque lo que yo voy a querer es que funcione para cada matriz que 
le paso independiente del nombre, pero al usar el struct tengo que especificar el nombre
del objeto, y eso me obligaría a crear una matriz de Simetrización para cada nuevo trabajo.

Veamos si podemos hacer algo con esto. Ok, probando en Prosem, cambiar el orden de los atributos
del struct Parametros no parece crear problemas. Lo cual es lo razonable, porque no los llamé
por ningún orden, los llamé por nombre. El motivo del error en la función main original 
sigue sin ser descubierto, mucho menos solucionado.

Ahora probemos a partir de una matriz inicial el pasarle a una función de visualización básica
el que me visualice mi matriz a partir de un puntero. Armé una visualización tranca haciendo
uso de esa idea de poner el tamaño de la matriz al principio. Está bueno el truco este.
Alguien mencionó también dejar un número para identificar el tipo de dato. Esa para el
futuro queda. No quiero sumar números al pedo, para no volverme loco en la definición
de valores y cosas.

Armé la función de visualización. Efectivamente, si defino el input como un puntero, y le
paso el puntero del struct entonces lo trabaja perfectamente. En este caso le pasé el
puntero red.Ady, es decir el que apunta a la matriz de Adyacencia de mi sistema, y me
lo graficó correctamente.

------------------------------------------------------------------------------------------

06/12/2020

Hoy lo que voy a hacer es un reformateo a todo incorporando nuevas prácticas de programación.
Estas consisten en:

.) Agregar una letra al nombre de una variable que defina el tipo de variable que es.
Esto lo separo del nombre de la función con un guión bajo. Los espacios en los
nombres los voy a separar con guiones bajos también. Es importante recordar
entonces que las primeras letras SIEMPRE indican el tipo de variable.

.) Voy a dejar espacios libres entre secciones de código, separando la parte de
inicializar, desarrollo, registro de datos y demás. También vamos a poner títulos.

.) En las primeras dos coordenadas de cada vector voy a colocar el tamaño del vector.
Siendo la primer coordenada las Filas y la segunda las Columnas.

Si sobra tiempo, armaré una función que haga un RK4. Aunque primero necesito una que
calcule correctamente el campo que define mi ecuación diferencial. Y estas funciones
necesitan ser probadas primero en Prosem para poder hacer las cuentas a mano y ver
que efectivamente hacen lo esperado.

##### Ya reformatee general.c y general.h ##########

##### Ya reformatee inicializar.c e inicializar.h ##########

Llegué al punto donde la función hace lo que ya hacía antes de empezar a formattear todo.
Mañana seguiré con esto. La idea es entonces primero armar la función de la ecuación
dinámica. Probarla que calcule correctamente. Hecho esto, pasamos a armar un RK4.
Es decir, mañana arrancamos laburando con el Prosem. Hecho esto, ya vamos a poder
poner el programa a evolucionar. Lo que va a quedar es registrar los datos y pasarlos
a Python.

Vamos a terminar el día de hoy subiendo todo lo correspondiente a Github. Vale
aclarar, los archivos avanzar los dejé afuera de la carpeta src, porque sino
al compilar el make all me los intenta levantar, y a esos todavía no los corregí.
Más que nada porque las funciones de la dinámica no están terminadas.

-----------------------------------------------------------------------------------------

07/12/2020

Corregí los nombres una vez más, porque ahora a los punteros les agregué la letra p.

Además, ya armé la función Din1 y la probé en el archivo Prosem. Ya lo testee y funciona,
tanto en el caso en que el sujeto no conecta con nadie como en el caso en que conecta con
alguien, la cuenta que hace es correcta. Estaría bueno conseguir un programa que me permita
hacer las cuentas con mayor facilidad, porque la verdad es una paja hacerlo en Geogebra.
Creo que voy a hacer las cuentas en Octave de ahora en más. Va a ser mejor, me puede hacer
los productos de matrices y eso va a ser mucho más rápido.

Voy a subir todo a Github ahora.

------------------------------------------------------------------------------------------

08/12/2020

Ya armé las funciones Din1 y Din2. Confío en que funcionan perfecto porque revisé las
cuentas yo mismo usando Octave. También, como para dejar constancia del test realizado
es que guardé una imagen que se llama Cáculos Din2. Es una imagen que tiene los
resultados obtenidos por el programa en C y las cuentas hechas con el Octave, donde
se puede ver que las pendientes calculadas en Octave coinciden totalmente con las 
calculadas en C. Para mayor claridad paso a describir qué son las matrices definidas
en Octave:

- Opi es la matriz de vectores de opinión transpuesto. El motivo de hacerlo transpuesto
es porque de esta manera el producto con la matriz Ang me daría en cada elemento la
suma de las opiniones de un agente en cada tópico ponderada por la superposición con
el tópico en cuestión. El hecho de usar la matriz de forma diferente a como lo hago en
C no implica ningún error de cuentas. No hay que olvidar que en C yo no tengo Matrices,
solamente tengo vectores muy largos. Por tanto el producto entre matrices y vectores
siempre lo termino armando yo. Y eso ya lo había revisado de que estaba bien.

- Ang es la matriz de superposición de tópicos. Por simplicidad, tiene unos en la
diagonal y 0.5 afuera.

- Sup es el producto de las matrices Ang y Opi. Como dije, contiene en cada elemento
la sumatoria de las opiniones de un cierto agente ponderadas según la superposición
de cada opinión con el tópico en consideración.

- Pendiente es el nómbre del resultado total del miembro de la derecha de la
ecuación diferencial.

- K es el parámetro homónimo de la ecuación diferencial. Representa la influencia social.

- alfa es el parámetro homónimo de la ecuación diferencial. Representa la
controversialidad de un tópico.

Ahora el chiste va a ser implementar el RK4. Estuve pensando en que el RK4 debería
tomar aparte de los structs, el puntero sobre el cual va a trabajar, el puntero
a la función que define el campo de mi problema, (En este caso sería Din2),
y algo interesante sería que tuviera un puntero propio dentro de la función.
Ese puntero debería guardar información sobre el estado inicial del puntero 
con el que voy a trabajar. Esa información va a ser necesaria durante el trabajo
RK4, pero terminada la función, se lo puede liberar y listo.

----------------------------------------------------------------------------------------

14/12/2020

Vamos a armar una función que realice el proceso de RK4. Mi idea es escribir una
función que sea bastante general. Para eso voy a tomar como referencia una versión
que encontré por internet. Todavía no tengo bien claras las ideas de cómo voy a
hacer funcionar la versión del RK4. Mi idea es que tome los structs y le pase
eso a la función. Por eso es que voy a estar dentro del RK4 trabajando la Matriz
de Opinión, definiéndola y redefiniéndola muchas veces.
Estaba con la duda de cómo guardar o manejar los datos correctamente, pero al
final llegué a la conclusión de que lo mejor sería tener vectores, definidos
por punteros como siempre, que me guarden los valores de las pendientes que
calculo para cada una de mis variables. Luego al final, luego de haber calculado
cada una de las pendientes, entonces sí uso todas las pendientes para calcular
el siguiente paso temporal del sistema.
Lo interesante para esto es que me di cuenta que iba a tener que hacer cada
cálculo de pendientes en orden, entonces tenía que escribir las 4 sumatorias.
Pero para simplificar la escritura de todas las sumatorias, se me ocurrió
usar un array de punteros. Por eso decidí probar el cómo usarlo en Prosem.
Ahí lo hice funcionar para que me genere la visualización de mi red.
Funciona bárbaro. Tengo que recordar no borrar eso. Voy a tener que
armar un protocolo de guardado de estas cosas. Mañana o en la semana,
lo próximo a hacer es ya implementar esto. Con esto ya básicamente tendría
armada la función del RK4. La paja va a ser comprobar que las cuentas están
bien hechas. Voy a estar un rato con el Octave mirando eso de seguro.

------------------------------------------------------------------------------------------

18/12/2020

Hoy avancé con la construcción de la función RK4. Hay varias cosas para 
discutir al respecto. Pero en términos de lo que quiero que haga, ya la
armé. Todavía no la probé ni revisé errores de tipeo, así que todavía
queda mucho hasta que esté lista. Además, todadvía estoy indeciso sobre
el formato de la función. Debería analizarlo un poco más, como para estar
seguro de que la función es perfectamente generalizable. Cosa que sería
de mucha utilidad.

Por otra parte, rearmé la función de visualizar, de manera de que sólo
tome un puntero de entrada y de eso haga la visualización. Para eso,
hice tres funciones, una que toma enteros, otra que toma floats y una
que toma doubles. Mi idea sería armar una función visualizar Global
que las encierre, que reciba un char que elija la función correcta 
y de ahí visualice. Aunque ahora que lo pienso, eso seguiría
teniendo el mismo problema de que no puedo pasar el vector que 
quiero a la función. ¿Habrá una forma de solucionar esto en el
futuro?

Cree una segunda función que es Duplicar, esa función me calcula
las pendientes de una ecuación diferencial que definí para probar
el RK4. La ecuación diferencial sería x' = 2x.

Volviendo al RK4, estoy empezando a usar más los arrays. También
introduje un array de chars, que eso también es nuevo para mi.
Hay muchas cosas, como los arrays, el meter un for para el free,
o el visualizar que podrían funcionar mal. Va a ver que mirar
todo eso la próxima vez. La próxima entonces hay que hacer
las cuentas y ver que el RK4 esté calculando bien.
Y después, repensar un poco la forma de que sea lo más general
posible. Quizás hacer unos gráficos escritos.

Pregunta importante, ¿Cómo guardar las distintas versiones de
cosas probadas en el Prosem? Podríamos hacer un archivo
llamado Archivo.c. Ahí voy guardando las cosas con descripción.
Así no me van ocupando espacio innecesario en mi archivo Prosem.
Me parece una idea genial.

------------------------------------------------------------------------------------------

21/12/2020

Estuve haciendo las pruebas del RK4 para hacerlo funcionar.
Increíblemente, pero en cuanto puse la función funco bastante
fácil, no tuvo tantos errores como esperaba.

Cuestión, hice las pruebas con ecuaciones diferenciales lineales
en las cuales la variación de mi variable estaba sujeta a
un múltiplo de su valor actual. Es decir, usé las ecuaciones
x'=2x y x'=5x. En la primera anoté los k manualmente y
comprobé que los cálculos estuvieran dando bien los k y
el valor final del sistema. Además, como conozco la solución
a estas ecuaciones puedo comprobar que tan lejos está lo
calculado con respecto a lo real. Elegí los valores de
dt y la constante que definen mi ecuación diferencial
de manera que evolucionar temporalmente un paso a mi sistema
sea equivalente a tomar los datos iniciales y multiplicarlos
por e en ambas ecuaciones.

Guardé una imagen que se llama cálculos RK4 en la cual se
puede ver a la derecha los resultados obtenidos por el 
programa RK4. Luego a la izquierda uso el Octave para
manualmente hacer los cálculos que el programa RK4 debería
estar haciendo. En este caso estoy evaluando el sistema
en el cual la ecuación diferencial es x'=5x. A continuación
está el paso a paso de las cuentas que hice:

.) Calculo k1 como los valores del sistema en tiempo t
multiplicados por 5.
.) Calculo k2 como los valores del sistema en tiempo t
sumados a k1 por dt/2 y todo eso multiplicado por 5
.) Calculo k3 como los valores del sistema en tiempo t
sumados a k2 por dt/2 y todo eso multiplicado por 5
.) Calculo k4 como los valores del sistema en tiempo t
sumados a k3 por dt y todo eso multiplicado por 5
.) Calculo el final como los valores del sistema en
tiempo t más el producto de dt sobre 6 con 
k1 más dos k2 más dos k3 más k4.
.) Corroboro el resultado de tomar los valores del
sistema a tiempo t y multiplicarlos por e.

Finalmente cabe notar que hay una diferencia en la 
segunda cifra decimal, lo cual marcaría que debería tomar
un avance temporal más chico del que tomé. Pero en conclusión,
el programa funciona perfecto. Me encanta. Sólo queda
pensar si se la puede hacer un poco más genérica y listo.

Ahora voy a incorporar esto al programa principal. Todavía no
terminé esto. Mañana lo primero que tengo que hacer es corregir
los struct que aparecen en todo el código y reemplazarlos
por los s_cosas. Con el tiempo se me ocurrirán formas de
hacer que eso funcione más fácil

----------------------------------------------------------------------------------

22/12/2020

Ya implementé el RK4 en el programa, funca bárbaro. Hice
las anotaciones sobre el bloque que creo es crucial para
la generalización de esta función en futuros trabajos.

Hice pruebas, el programa funciona muy bien, no tira
errores ni nada. Por ahora lo único que probé a variar
son los valores de K y los de la matriz de Superposición.
Los resultados son los siguientes:

.) Si los valores de la matriz de Superposición son todos
positivos, entonces todos los signos de los tópicos se
alinean.
.) Si los signos de los valores de la matriz de Superposición
se alternan, entonces lo que me ocurre es que los signos
de las columnas se alternan igualmente.
.) Si reduzco el valor de K a cero, el sistema tiende a cero.
.) Si aumento el valor de K el sistema al evolucionar
simplemente tiende a crecer.
.) Con un valor de Tiempo de integración = 20, el sistema
con K=0 logra llegar a un estado donde todos los agentes
tienen opinión nula en todos los tópicos.

Ahora lo que voy a hacer es cortar acá, mostrarle esto
a Pablo mañana y de ahí decidir qué vamos a hacer.
Si yo estuviera por mi cuenta y tuviera que decidir,
¿Cuál sería mi siguiente paso?

Razonablemente, yo diría que por ahora lo que tengo
entonces son sólo dos fotos, la inicial y la final
y que este fue un análisis muy cualitativo. Para
poder empezar a hacer un análisis más cuantitativo
voy a necesitar ver lo que ocurre durante el proceso.

Por tanto los siguientes objetivos serían:
1) Implementar una forma de tomar registro de
los datos para poder guardar mis vectores de
opinión.
2) Armar un programa para cargar estos datos a
Python.
3) Hacer un análisis de los datos. Para esto hay
que pensar de qué forma deberían graficarse los datos.
Se me ocurre que el caso de K=0 se pueden graficar
curvas de variación del valor promedio de la opinión
en cada tópico y ver cómo eso cae a cero.
4) Podría graficar el caso de K != 0 considerando la
direccionalidad de los vectores. Sería una forma
cualitativa pero un poco mejor que lo que tengo
ahora de visualizar la evolución del sistema. Me armo
una especie de Histograma donde voy contando cuántas
personas apuntan en cierta dirección, y las
direcciones las defino en base al signo del tópico.
Eso me ayudaría a ver cómo se van moviendo las personas
de una opinión a otra y si la condición inicial del
sistema afecta mucho al resultado final.
5) Otra opción viable es armar un scatter de puntos
de colores, donde cada color representa una opinión
y luego ir acercando los colores cuyas opiniones son
más similares.